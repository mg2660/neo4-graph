<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Network Graph - Latency Paths</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      color: white;
      font-family: sans-serif;
    }
    svg {
      width: 100vw;
      height: 100vh;
    }
    .tooltip {
      position: absolute;
      text-align: center;
      padding: 5px;
      font-size: 12px;
      background: white;
      color: black;
      border: 1px solid #ccc;
      pointer-events: none;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <svg></svg>
  <script>
    const svg = d3.select("svg");
    const width = window.innerWidth;
    const height = window.innerHeight;const colorStyles = [
  { color: "#00ffff", filter: "url(#glow-cyan)" },
  { color: "#ffa500", filter: "url(#glow-orange)" },
  { color: "#ff69b4", filter: "url(#glow-pink)" }
];

const defs = svg.append("defs");
const filters = [
  { id: "glow-cyan", stdDeviation: 2.5 },
  { id: "glow-orange", stdDeviation: 2.5 },
  { id: "glow-pink", stdDeviation: 2.5 }
];
filters.forEach(f => {
  const filter = defs.append("filter").attr("id", f.id);
  filter.append("feGaussianBlur")
    .attr("stdDeviation", f.stdDeviation)
    .attr("result", "coloredBlur");
  const merge = filter.append("feMerge");
  merge.append("feMergeNode").attr("in", "coloredBlur");
  merge.append("feMergeNode").attr("in", "SourceGraphic");
});

const tooltip = d3.select("body").append("div")
  .attr("class", "tooltip")
  .style("opacity", 0);

fetch("latency-data.json")
  .then(res => res.json())
  .then(data => {
    const nodes = data.nodes.map(d => Object.assign({}, d));
    const links = data.links.map(d => Object.assign({}, d));

    const nodeById = Object.fromEntries(nodes.map(d => [d.id, d]));
    links.forEach(l => {
      l.source = nodeById[l.source];
      l.target = nodeById[l.target];
    });

    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(100))
      .force("charge", d3.forceManyBody().strength(-500))
      .force("center", d3.forceCenter(width / 2, height / 2));

    const link = svg.append("g")
      .attr("stroke", "#0f0")
      .attr("stroke-opacity", 0.6)
      .selectAll("line")
      .data(links)
      .join("line")
      .attr("stroke-width", 2);

    const node = svg.append("g")
      .attr("stroke", "#fff")
      .attr("stroke-width", 1.5)
      .selectAll("circle")
      .data(nodes)
      .join("circle")
      .attr("r", 8)
      .attr("fill", d => d.alarm_status === "RED" ? "red" : "#00f")
      .call(drag(simulation));

    node.append("title").text(d => d.id);

    node.on("mouseover", (event, d) => {
      tooltip.transition().duration(200).style("opacity", 0.9);
      tooltip.html(d.id).style("left", event.pageX + "px").style("top", (event.pageY - 28) + "px");
    }).on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));

    simulation.on("tick", () => {
      link.attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

      node.attr("cx", d => d.x).attr("cy", d => d.y);
    });

    function drag(simulation) {
      return d3.drag()
        .on("start", event => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          event.subject.fx = event.subject.x;
          event.subject.fy = event.subject.y;
        })
        .on("drag", event => {
          event.subject.fx = event.x;
          event.subject.fy = event.y;
        })
        .on("end", event => {
          if (!event.active) simulation.alphaTarget(0);
          event.subject.fx = null;
          event.subject.fy = null;
        });
    }

    // Dijkstra's algorithm
    function dijkstra(sourceId, targetId, excludedIds = new Set()) {
      const distances = {}, prev = {}, queue = new Set(nodes.map(n => n.id));
      nodes.forEach(n => distances[n.id] = Infinity);
      distances[sourceId] = 0;

      while (queue.size) {
        const u = [...queue].reduce((min, id) => distances[id] < distances[min] ? id : min);
        queue.delete(u);
        if (u === targetId) break;
        const neighbors = links.filter(l =>
          (l.source.id === u && !excludedIds.has(l.target.id)) ||
          (l.target.id === u && !excludedIds.has(l.source.id)));
        for (const l of neighbors) {
          const v = l.source.id === u ? l.target.id : l.source.id;
          const alt = distances[u] + l.latency;
          if (alt < distances[v]) {
            distances[v] = alt;
            prev[v] = u;
          }
        }
      }

      const path = [];
      let u = targetId;
      if (prev[u] || u === sourceId) {
        while (u) {
          path.unshift(u);
          u = prev[u];
        }
      }
      return { path, latency: distances[targetId] };
    }

    function findMultiplePaths(sourceId, targetId, count = 3) {
      const paths = [], visitedEdges = new Set();
      const excludedNodes = new Set(nodes.filter(n => n.alarm_status === "RED").map(n => n.id));

      for (let i = 0; i < count; i++) {
        const result = dijkstra(sourceId, targetId, excludedNodes);
        if (!result.path.length) break;
        paths.push(result);
        for (let j = 0; j < result.path.length - 1; j++) {
          excludedNodes.add(result.path[j]); // prevent reuse of same nodes
        }
      }
      return paths;
    }

    function highlightPaths(paths) {
      d3.selectAll("line").style("stroke", "#0f0").style("filter", null).style("stroke-width", 2);
      d3.selectAll("circle").style("stroke", "#fff").style("stroke-width", 1.5);

      paths.forEach((p, i) => {
        const { color, filter } = colorStyles[i % colorStyles.length];
        for (let j = 0; j < p.path.length - 1; j++) {
          const from = p.path[j], to = p.path[j+1];
          d3.selectAll("line")
            .filter(d =>
              (d.source.id === from && d.target.id === to) ||
              (d.source.id === to && d.target.id === from))
            .style("stroke", color)
            .style("stroke-width", 4)
            .style("filter", filter);
        }
        d3.selectAll("circle")
          .filter(d => p.path.includes(d.id))
          .style("stroke", color)
          .style("stroke-width", 3);
      });
    }

    const source = "NodeA";
    const target = "NodeZ";
    const bestPaths = findMultiplePaths(source, target);
    highlightPaths(bestPaths);
  });

  </script>
</body>
</html>
